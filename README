#
##############################################################################
# UNIXという考え方  メモ　
# 鈴木　維一郎　suzuki.iichiro
##############################################################################
#
# keyword:
#echo awk sed grep cat head tail sort uniq tr wc tee cut tee expr nkf touch xargs tac rev cp curl wget date du find read sleep file mpage xwd basename nroff pr dd split join merge cmp more less fold diff expand paste test
#
#■１．小さいものは美しい　「スモールイズビューティフル」
#　　「伝統的なプログラマは、巨大なアメリカンプログラムによって、
#　　　　世界中の全ての問題を一つのプログラムで解決しようとする。」
#　　「プログラムの９０％はクズである。
#　　　　ただしあらゆるものの９０％はクズである。」
#
#■２．一つのプログラムには一つの事をうまくやらせる　「わかることは分けること」
#　　「UNIXユーザーは、自分が何をしているのかをわかっている。
#　　　　何をしているのかわからないのなら、ここにいるべきではない」
#　　「一つの事をうまくやるようにプログラムを作れないのであれば、
#　　　　おそらく問題をまだ完全に理解していない。」
#
#■３．出来るだけ早く試作する　「反復と協調」
#　　「試作によって学ぶ。早い試作はリスクを減らす。
#　　　「正しく」やっている時間などない」
#　　「「なにができるか」
#　　　　むしろ重要な事は、「なにができないか」を知る事だ。」
#
#■４．効率より移植性　bashとawkとsed
#　　「最も効率の良い方法は、
#　　　　ほとんどの場合「移植性」に欠ける。」
#　　「移植か死か。優れたソフトウェアは移植され成長し、
#　　　　それ以外は取り残され捨てられる。」
#
#■５．出力結果はASCIIフラットファイルに保存する　中間ファイルは作らない　RDBは使わない
#　　「動かせないデータは死んだデータだ。」
#
#■６．ソフトウェアを梃子として使う　
#　　「良いプログラマはよいコードを書く。
#　　　　偉大なプログラマは良いコードを借りてくる。」
#
#■７．シェルスクリプトによって梃子の効果と移植性を高める　パイプ
#　　「私は人生で二度しか奇跡を見た事がない。
#　　　　一つは核融合、もう一つは複利だ
#　　　　　少量のものを繰り返し掛け合わせていく事で、
#　　　　　　やがて奇跡的な規模に達する。」
#
#■８．全てのプログラムをフィルタとして設計する
#　　　メソッド間の入力をstdin、出力はstdoutを使用する
#
#■９．並行して考える
#　　　並列処理が可能なメソッドを積極的に書く
#
#■１０．木を守る
#　　　UNIXはドキュメントを忌み嫌う
#
#
#■１．「小さいものは美しい」
#
#　　小さなプログラムはわかりやすい
#　　小さなプログラムは保守しやすい
#　　小さなプログラムはシステムリソースに易しい
#　　小さなプログラムは他のツールと組み合わせやすい
#
#　　「伝統的なプログラマは、巨大なアメリカンプログラムによって、
#　　　　世界中の全ての問題を一つのプログラムで解決しようとする。」
#　　「プログラムの９０％はクズである。
#　　　　ただしあらゆるものの９０％はクズである。」
#
#　　パラメータが一行に収まらない
#　　メソッドが画面に収まらない
#　　コメントを読まないと何をやっているのか思い出せない
#　　lsでモジュール名が多すぎて画面の端から消えていってしまう
#　　まだ開発中なのにエラーメッセージの意味を思い出せない
#　　整理するためにソースコードを印刷している自分に気がついた
#
#
#■２．一つのプログラムには一つの事をうまくやらせる
#
#　　a)ユーザーとの対話が必要か。パラメータではだめか
#　　b)入力データは特殊フォーマットが必要か。フォーマット変換プログラムがすでにシステム上にないか。
#　　c)出力データは特殊フォーマットが必要か。通常のASCIIファイルではだめか。
#　　d)新しいプログラムを書かずとも似たような機能を持つ他のプログラムがあるのではないか。
#
#　　「一つの事をうまくやるようにプログラムを作れないのであれば、
#　　　　おそらく問題をまだ完全に理解していない。」
#　　「しのびよる多機能主義。
#　　　　プログラマはいつだってプログラムを遅くする方法を見つける。」
#
#　　一つの事をうまくやるようにアプリケーションを書けば、それは必然的に小さなプログラムになる。
#　　小さなプログラムは単一機能になる傾向があり、単一機能のプログラムは小さくなる傾向がある。
#
#■３．出来るだけ早く試作する
#
#　　「試作によって学ぶ。早い試作はリスクを減らす。
#　　　「正しく」やっている時間などない」
#　　「「なにができるか」
#　　　　むしろ重要な事は、「なにができないか」を知る事だ。」
#
#　　三つのシステム
#　　１．第一のシステム
#　　　第一のシステムは正しくやっている時間などない。
#　　　第一のシステムは追い詰められた人間が作る。
#　　　第一のシステムのコンセプトは人々の想像力を刺激する。
#　　　第一のシステムは一人かせいぜい数人からなる小さなグループで作られる。
#　　　第一のシステムは高い情熱によって推進され開発は急速に進む。
#　　　第一のシステムは実に性能がよい。
#
#　　２．第二のシステム
#　　　第二のシステムは第一のシステムで証明されたアイデアを継承する。
#　　　第二のシステムは委員会が設計する。
#　　　第二のシステムは委員会によりものごとを全て公開の場で自分自身の正当化のために議論を進める。
#　　　第二のシステムは第一のシステムの成功に便乗し分け前にあずかろうとする自称専門家で作られる。
#　　　第二のシステムは自称専門家によりリポジトリ、進捗管理ツールが導入され計画は遅延する。
#　　　第二のシステムは自称専門家のプログラムにおきかえられ贅肉がつき像のようにゆっくり動く。
#　　　第二のシステムは「最初の設計のひどい欠点を見違えるように改善」され多機能となり無知が使う。
#　　　第二のシステムは三つのシステムの中で最悪のシステムである。
#
#　　３．第三のシステム
#　　　第三のシステムはこれまでのシステムへの反抗から生まれる。
#　　　第三のシステムの名前が変わり、オリジナルのアイデアはもはや常識となる。
#　　　第三のシステムは第一と第二のシステムの最良の特徴を組み合わせる。
#　　　第三のシステムは設計者にとってようやく「正しく」やる事が出来る。
#　　　第三のシステムはユーザーが実際に使用する機能しか含まれない。
#　　　第三のシステムはディスク、メモリ、CPUサイクルなど最適なバランスが実現されている。
#　　　第三のシステムは提供される性能レベルも良くバランスがとれている。
#
#　　第一のシステムとして「試作」を１ナノ秒でも早く作り、
#　　　第一のシステムと第二のシステムのサイクルを反復と協調し、
#　　　　第三のシステムに向かって協力しながら進んでいく。
#
#■４．効率より移植性
#　　UNIXにおいてそれはシェルスクリプトしかない。
#　　次のハードウェアはもっと速く走る。だからプログラムを速くするという誘惑に負けない。
#　　わずかな速度を求めてCで書き直さない。それは時間の無駄だ。
#
#　　シェルスクリプトをあれこれいじる余裕が一瞬でも生じればほとんどのプログラマは
#          a) 新しい機能をいくつか付け加えようとする
#　　　b) スクリプトそのものを洗練し、実行速度を高めようとする
#　　　c) その一部、または大部分をCで書き直してパフォーマンスの向上を図ろうとする。
#
#　　「最も効率の良い方法は、
#　　　　ほとんどの場合「移植性」に欠ける。」
#　　「移植か死か。優れたソフトウェアは移植され成長し、
#　　　　それ以外は取り残され捨てられる。」
#
#　　DQ1カートリッジ(64kb)用のコード
#　　　自分のプログラマ人生で最も効率の良い、そして移植の難しいコード」を書いた。
#　　　命令をデータとして扱い、データを命令として扱った。
#　　　走査線が画面の右端から左端に引き返すまでの間を狙って命令を実行した。
#　　　メモリ節約のためありとあらゆる技を駆使した。
#　　　こうしてできあがったコードは芸術品と言えるほど見事なものだった。
#　　　フォルクスワーゲンのビートルに２０人ほど詰め込むようなものだった。
#　　　そして保守担当者にとっては究極の悪夢でもあった。
#　　
#■５．出力結果はASCIIフラットファイルに保存する　中間ファイルは作らない　RDBは使わない
#
#　　「動かせないデータは死んだデータだ。」
#
#　　出力結果はASCIIフラットファイルに保存する。
#　　RDBを使わない。
#　　中間ファイルをはき出さない。
#　　
#■６．ソフトウェアを梃子として使う
#　　梃子の支点をいかに自分のほうに近づける事が出来るか
#　　独自技術症候群を避け、すでにあるものにクリエイティブな付加価値をつける
#　　独自技術症候群は創造性を伸ばさない。
#
#　　「良いプログラマはよいコードを書く。
#　　　　偉大なプログラマは良いコードを借りてくる。」
#　　
#■７．シェルスクリプトによって梃子の効果と移植性を高める
#
#　　シェルスクリプトには恐ろしいほどの梃子の効果がある
#　　シェルスクリプトは梃子の降下で時間も節約する
#　　シェルスクリプトはCより移植性が高い
#
#　　「熟練プログラマはシェルスクリプトを熱心に使う。
#　　　　あなたもまたそうするべきだ。」
#　　「UNIXの源流は高水準の抽象化モデル「シェルスクリプト」であり、
#　　　　それは今も普遍である。」
#　　「私は人生で二度しか奇跡を見た事がない。
#　　　　一つは核融合、もう一つは複利だ
#　　　少量のものを繰り返し掛け合わせていく事で、
#　　　　やがて奇跡的な規模に達する。」アインシュタイン
#
#　　シェルスクリプト一行はおよそ１万倍の複利を生む
#　　echo who | awk '{ print $1 ; }' | sort | uniq | sed -e "s/  /,  /g" ;
#
#　　echo   177
#　　who    755
#　　awk   3411
#　　sort  2614
#　　uniq    302
#　　sed   2093
#-------------------------
#　　　　  9.353
#
#　　処理をパイプでつなぎ処理全体を一行で完結させる。
#　　「ひとつのことをうまくやる」の良い事例だ。
#　　function sh_func_getTitle() {
#　　  TITLE=$(echo ${URLGETOPT} | \
#　　    while read line ;do
#　　      if echo "$line" | grep -i "title=" > /dev/null; then
#　　        echo "$line" | \
#　　          sed -e "s/^.*title=\x27//g" \
#　　              -e "s/\x27.*$//g" \
#　　              -e "s/\r//g" \
#　　              -e "s/<[^>]*>//g" \
#　　              -e "s/^[●○■□△▽]//g"; 
#　　      fi
#　　    done);
#　　}
#
#■８．全てのプログラムをフィルタとして設計する
#　　
#　　メソッド間の入力をstdin、出力はstdoutを使用する
#　　オンメモリでコマンドフィルタとして稼働する。
#      function trim(){
#　　　if [ -p /dev/stdin ]; then
#　　 　   cat - ;
#　　　else
#               echo -n ;
#　　　fi | sed -e 's/^ *//g' -e 's/ *$//g'
#　　}
#
#　　実行結果
#      echo "      ほげ      " | trim ;
#      ほげ
#
#　　以下でも良い。　　
#　　function trim(){
#　　　awk '{ print $1; }' | sed -e 's/^ *//g' -e 's/ *$//g'  </dev/stdin
#　　}
#
#　　実行結果
#      echo "      ほげ      " | trim ;
#      ほげ
#
#■９．平行して考える
#
# 　　並列処理が可能なメソッドを積極的に書く
#
# 　　 メソッドの並列処理
# 　　  1 #!/bin/bash
# 　　  2 cmd() { 
#  　　 3    echo "Hello, $1!"; 
# 　　  4 }
# 　　  5 function sh_xargs(){
# 　　  6 　export -f cmd
# 　　  7  　yes | head -1000 | xargs -n1 -P4 -I % bash -c "cmd %"
# 　　  8 }
# 　　  9 sh_xargs ;
#
#■１０．木を守る
#　　UNIXユーザーは紙のドキュメントを忌み嫌う。不要なドキュメントを印刷して整理する事はしない。
#　　ソースコードが実体であり、高水準のドキュメントとなるようプログラムする。
#
#
