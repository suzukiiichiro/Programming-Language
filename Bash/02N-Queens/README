##
 # Bash(シェルスクリプト)で学ぶアルゴリズムとデータ構造  
 # 一般社団法人  共同通信社  情報技術局  鈴木  維一郎(suzuki.iichiro@kyodonews.jp)
 #
 # Java/C/Lua/Bash版
 # https://github.com/suzukiiichiro/N-Queen
 #
 # ステップバイステップでＮ−クイーン問題を最適化
 #  １．ブルートフォース（力まかせ探索） NQueen1()
 #  ２．配置フラグ（制約テスト高速化）   NQueen2()
 #  ３．バックトラック                   NQueen3()
 #  ４．ビットマップ                     NQueen4()
 #  ５．ユニーク解                       NQueen5()
 #
 #
 ############################################
 # N-Queen
 ############################################
 #
 ##
 # 再帰  Nクイーン問題
 #
 # https://ja.wikipedia.org/wiki/エイト・クイーン
 #
 # N-Queens問題とは
 #    Nクイーン問題とは、「8列×8行のチェスボードに8個のクイーンを、互いに効きが
 #    当たらないように並べよ」という８クイーン問題のクイーン(N)を、どこまで大き
 #    なNまで解を求めることができるかという問題。
 #    クイーンとは、チェスで使われているクイーンを指し、チェス盤の中で、縦、横、
 #    斜めにどこまでも進むことができる駒で、日本の将棋でいう「飛車と角」を合わ
 #    せた動きとなる。８列×８行で構成される一般的なチェスボードにおける8-Queens
 #    問題の解は、解の総数は92個である。比較的単純な問題なので、学部レベルの演
 #    習問題として取り上げられることが多い。
 #    8-Queens問題程度であれば、人力またはプログラムによる「力まかせ探索」でも
 #    解を求めることができるが、Nが大きくなると解が一気に爆発し、実用的な時間で
 #    は解けなくなる。
 #    現在すべての解が判明しているものは、2004年に電気通信大学で264CPU×20日をか
 #    けてn=24を解決し世界一に、その後2005 年にニッツァ大学でn=25、2016年にドレ
 #    スデン工科大学でn=27の解を求めることに成功している。
 # 
 #
 #   ステップ
 # 
 #  １．ブルートフォース（力まかせ探索） NQueen1()
 #  ２．バックトラック                   NQueen2()
 #  ３．配置フラグ（制約テスト高速化）   NQueen3()
 #  ４．ビットマップ                     NQueen4()
 #  ５．対称解除法(回転と斜軸）          NQueen5()
 #  ６．マルチスレッド                   NQueen6()
##
##

## 1. ブルートフォース　力任せ探索
 #　全ての可能性のある解の候補を体系的に数え上げ、それぞれの解候補が問題の解と
 #  なるかをチェックする方法
 #  (※)各行に１個の王妃を配置する組み合わせを再帰的に列挙組み合わせを生成するだ
 #  けであって8王妃問題を解いているわけではありません
#  :
#  :
#  7 7 7 7 7 7 6 7 : 16777208
#  7 7 7 7 7 7 7 0 : 16777209
#  7 7 7 7 7 7 7 1 : 16777210
#  7 7 7 7 7 7 7 2 : 16777211
#  7 7 7 7 7 7 7 3 : 16777212
#  7 7 7 7 7 7 7 4 : 16777213
#  7 7 7 7 7 7 7 5 : 16777214
#  7 7 7 7 7 7 7 6 : 16777215
#  7 7 7 7 7 7 7 7 : 16777216



##
 # ２．配置フラグ（制約テスト高速化）
 #  パターンを生成し終わってからチェックを行うのではなく、途中で制約を満たさな
 #  い事が明らかな場合は、それ以降のパターン生成を行わない。
 # 「手を進められるだけ進めて、それ以上は無理（それ以上進めても解はない）という
 # 事がわかると一手だけ戻ってやり直す」という考え方で全ての手を調べる方法。
 # (※)各行列に一個の王妃配置する組み合わせを再帰的に列挙分枝走査を行っても、組
 # み合わせを列挙するだけであって、8王妃問題を解いているわけではありません。
 #
#  :
#  :
#  7 6 5 4 2 0 3 1 : 40310
#  7 6 5 4 2 1 0 3 : 40311
#  7 6 5 4 2 1 3 0 : 40312
#  7 6 5 4 2 3 0 1 : 40313
#  7 6 5 4 2 3 1 0 : 40314
#  7 6 5 4 3 0 1 2 : 40315
#  7 6 5 4 3 0 2 1 : 40316
#  7 6 5 4 3 1 0 2 : 40317
#  7 6 5 4 3 1 2 0 : 40318
#  7 6 5 4 3 2 0 1 : 40319
#  7 6 5 4 3 2 1 0 : 40320



 # ３．バックトラック
 #  　各列、対角線上にクイーンがあるかどうかのフラグを用意し、途中で制約を満た
 #  さない事が明らかな場合は、それ以降のパターン生成を行わない。
 #  　各列、対角線上にクイーンがあるかどうかのフラグを用意することで高速化を図る。
 #  　これまでは行方向と列方向に重複しない組み合わせを列挙するものですが、王妃
 #  は斜め方向のコマをとることができるので、どの斜めライン上にも王妃をひとつだ
 #  けしか配置できない制限を加える事により、深さ優先探索で全ての葉を訪問せず木
 #  を降りても解がないと判明した時点で木を引き返すということができます。
##
# N:        Total       Unique     hh:mm:ss
# 2:            0            0            0
# 3:            0            0            0
# 4:            2            0            0
# 5:           10            0            0
# 6:            4            0            0
# 7:           40            0            0
# 8:           92            0            1
# 9:          352            0            1
#10:          724            0            7
#11:         2680            0           33
#12:        14200            0          183
##


 #
 #  4．ビットマップ
 #
 #   ビット演算を使って高速化 状態をビットマップにパックし、処理する
 #   単純なバックトラックよりも２０〜３０倍高速
 # 
 # 　ビットマップであれば、シフトにより高速にデータを移動できる。
 #  フラグ配列ではデータの移動にO(N)の時間がかかるが、ビットマップであればO(1)
 #  フラグ配列のように、斜め方向に 2*N-1の要素を用意するのではなく、Nビットで充
 #  分。
 #
 # 　配置可能なビット列を flags に入れ、-flags & flags で順にビットを取り出し処理。
 # 　バックトラックよりも２０−３０倍高速。
 # 
 # ===================
 # 考え方 1
 # ===================
 #
 # 　Ｎ×ＮのチェスボードをＮ個のビットフィールドで表し、ひとつの横列の状態をひと
 # つのビットフィールドに対応させます。(クイーンが置いてある位置のビットをONに
 # する)
 # 　そしてバックトラッキングは0番目のビットフィールドから「下に向かって」順にい
 # ずれかのビット位置をひとつだけONにして進めていきます。
 #
 # 
 #- - - - - Q - -    00000100 0番目のビットフィールド
 #- - - Q - - - -    00010000 1番目のビットフィールド
 #- - - - - - Q -    00000010 2番目のビットフィールド
 #Q - - - - - - -    10000000 3番目のビットフィールド
 #- - - - - - - Q    00000001 4番目のビットフィールド
 #- Q - - - - - -    01000000 5番目のビットフィールド
 #- - - - Q - - -    00001000 6番目のビットフィールド
 #- - Q - - - - -    00100000 7番目のビットフィールド
 #
 #
 # ===================
 # 考え方 2
 # ===================
 #
 # 次に、効き筋をチェックするためにさらに３つのビットフィールドを用意します。
 #
 # 1. 左下に効き筋が進むもの: left 
 # 2. 真下に効き筋が進むもの: down
 # 3. 右下に効き筋が進むもの: right
 #
 #次に、斜めの利き筋を考えます。
 # 上図の場合、
 # 1列目の右斜め上の利き筋は 3 番目 (0x08)
 # 2列目の右斜め上の利き筋は 2 番目 (0x04) になります。
 # この値は 0 列目のクイーンの位置 0x10 を 1 ビットずつ「右シフト」すれば求める
 # ことができます。
 # また、左斜め上の利き筋の場合、1 列目では 5 番目 (0x20) で 2 列目では 6 番目 (0x40)
 #になるので、今度は 1 ビットずつ「左シフト」すれば求めることができます。
 #
 #つまり、右シフトの利き筋を right、左シフトの利き筋を left で表すことで、クイー
 #ンの効き筋はrightとleftを1 ビットシフトするだけで求めることができるわけです。
 #
 #  *-------------
 #  | . . . . . .
 #  | . . . -3. .  0x02 -|
 #  | . . -2. . .  0x04  |(1 bit 右シフト right)
 #  | . -1. . . .  0x08 -|
 #  | Q . . . . .  0x10 ←(Q の位置は 4   down)
 #  | . +1. . . .  0x20 -| 
 #  | . . +2. . .  0x40  |(1 bit 左シフト left)  
 #  | . . . +3. .  0x80 -|
 #  *-------------
 #  図：斜めの利き筋のチェック
 #
 # n番目のビットフィールドからn+1番目のビットフィールドに探索を進めるときに、そ
 # の３つのビットフィールドとn番目のビットフィールド(bit)とのOR演算をそれぞれ行
 # います。leftは左にひとつシフトし、downはそのまま、rightは右にひとつシフトして
 # n+1番目のビットフィールド探索に渡してやります。
 #
 # left : (left |bit)<<1
 # right: (right|bit)>>1
 # down :   down|bit
 #
 #
 # ===================
 # 考え方 3
 # ===================
 #
 #   n+1番目のビットフィールドの探索では、この３つのビットフィールドをOR演算した
 # ビットフィールドを作り、それがONになっている位置は効き筋に当たるので置くことが
 # できない位置ということになります。次にその３つのビットフィールドをORしたビッ
 # トフィールドをビット反転させます。つまり「配置可能なビットがONになったビットフィー
 # ルド」に変換します。そしてこの配置可能なビットフィールドを bitmap と呼ぶとして、
 # 次の演算を行なってみます。
 # 
 # bit = -bitmap & bitmap; //一番右のビットを取り出す
 # 
 #   この演算式の意味を理解するには負の値がコンピュータにおける２進法ではどのよう
 # に表現されているのかを知る必要があります。負の値を２進法で具体的に表わしてみる
 # と次のようになります。
 # 
 #  00000011   3
 #  00000010   2
 #  00000001   1
 #  00000000   0
 #  11111111  -1
 #  11111110  -2
 #  11111101  -3
 # 
 #   正の値nを負の値-nにするときは、nをビット反転してから+1されています。そして、
 # 例えばn=22としてnと-nをAND演算すると下のようになります。nを２進法で表したときの
 # 一番下位のONビットがひとつだけ抽出される結果が得られるのです。極めて簡単な演算
 # によって1ビット抽出を実現させていることが重要です。
 # 
 #      00010110   22
 #  AND 11101010  -22
 # ------------------
 #      00000010
 # 
 #   さて、そこで下のようなwhile文を書けば、このループは bitmap のONビットの数の
 # 回数だけループすることになります。配置可能なパターンをひとつずつ全く無駄がなく
 # 生成されることになります。
 # 
 # while (bitmap) {
 #     bit = -bitmap & bitmap;
 #     bitmap ^= bit;
 #     //ここでは配置可能なパターンがひとつずつ生成される(bit) 
 # }

##
# ビットマップ
#
# N:        Total       Unique     hh:mm:ss
# 2:            0            0            0
# 3:            0            0            0
# 4:            2            0            0
# 5:           10            0            0
# 6:            4            0            0
# 7:           40            0            0
# 8:           92            0            0
# 9:          352            0            1
#10:          724            0            3
#11:         2680            0           14
#12:        14200            0           71
#13:        73712            0          392
##


##
# 5. 対称解除法 ユニーク解(回転・反転）を使って高速化
##


 #  5．対称解除法
 #     一つの解には、盤面を９０度、１８０度、２７０度回転、及びそれらの鏡像の合計
 #     ８個の対称解が存在する。対照的な解を除去し、ユニーク解から解を求める手法。
 # 
 # ■ユニーク解の判定方法
 #   全探索によって得られたある１つの解が、回転・反転などによる本質的に変わること
 # のない変換によって他の解と同型となるものが存在する場合、それを別の解とはしない
 # とする解の数え方で得られる解を「ユニーク解」といいます。つまり、ユニーク解とは、
 # 全解の中から回転・反転などによる変換によって同型になるもの同士をグループ化する
 # ことを意味しています。
 # 
 #   従って、ユニーク解はその「個数のみ」に着目され、この解はユニーク解であり、こ
 # の解はユニーク解ではないという定まった判定方法はありません。ユニーク解であるか
 # どうかの判断はユニーク解の個数を数える目的の為だけに各個人が自由に定義すること
 # になります。もちろん、どのような定義をしたとしてもユニーク解の個数それ自体は変
 # わりません。
 # 
 #   さて、Ｎクイーン問題は正方形のボードで形成されるので回転・反転による変換パター
 # ンはぜんぶで８通りあります。だからといって「全解数＝ユニーク解数×８」と単純には
 # いきません。ひとつのグループの要素数が必ず８個あるとは限らないのです。Ｎ＝５の
 # 下の例では要素数が２個のものと８個のものがあります。
 #
 #
 # Ｎ＝５の全解は１０、ユニーク解は２なのです。
 # 
 # グループ１: ユニーク解１つ目
 # - - - Q -   - Q - - -
 # Q - - - -   - - - - Q
 # - - Q - -   - - Q - -
 # - - - - Q   Q - - - -
 # - Q - - -   - - - Q -
 # 
 # グループ２: ユニーク解２つ目
 # - - - - Q   Q - - - -   - - Q - -   - - Q - -   - - - Q -   - Q - - -   Q - - - -   - - - - Q
 # - - Q - -   - - Q - -   Q - - - -   - - - - Q   - Q - - -   - - - Q -   - - - Q -   - Q - - -
 # Q - - - -   - - - - Q   - - - Q -   - Q - - -   - - - - Q   Q - - - -   - Q - - -   - - - Q -
 # - - - Q -   - Q - - -   - Q - - -   - - - Q -   - - Q - -   - - Q - -   - - - - Q   Q - - - -
 # - Q - - -   - - - Q -   - - - - Q   Q - - - -   Q - - - -   - - - - Q   - - Q - -   - - Q - -
 #
 # 
 #   それでは、ユニーク解を判定するための定義付けを行いますが、次のように定義する
 # ことにします。各行のクイーンが右から何番目にあるかを調べて、最上段の行から下
 # の行へ順番に列挙します。そしてそれをＮ桁の数値として見た場合に最小値になるもの
 # をユニーク解として数えることにします。尚、このＮ桁の数を以後は「ユニーク判定値」
 # と呼ぶことにします。
 # 
 # - - - - Q   0
 # - - Q - -   2
 # Q - - - -   4   --->  0 2 4 1 3  (ユニーク判定値)
 # - - - Q -   1
 # - Q - - -   3
 # 
 # 
 #   探索によって得られたある１つの解(オリジナル)がユニーク解であるかどうかを判定
 # するには「８通りの変換を試み、その中でオリジナルのユニーク判定値が最小であるか
 # を調べる」ことになります。しかし結論から先にいえば、ユニーク解とは成り得ないこ
 # とが明確なパターンを探索中に切り捨てるある枝刈りを組み込むことにより、３通りの
 # 変換を試みるだけでユニーク解の判定が可能になります。
 #  
 # 
 # ■ユニーク解の個数を求める
 #   先ず最上段の行のクイーンの位置に着目します。その位置が左半分の領域にあればユ
 # ニーク解には成り得ません。何故なら左右反転によって得られるパターンのユニーク判
 # 定値の方が確実に小さくなるからです。また、Ｎが奇数の場合に中央にあった場合はど
 # うでしょう。これもユニーク解には成り得ません。何故なら仮に中央にあった場合、そ
 # れがユニーク解であるためには少なくとも他の外側の３辺におけるクイーンの位置も中
 # 央になければならず、それは互いの効き筋にあたるので有り得ません。
 #
 #
 # ***********************************************************************
 # 最上段の行のクイーンの位置は中央を除く右側の領域に限定されます。(ただし、N ≧ 2)
 # ***********************************************************************
 # 
 #   次にその中でも一番右端(右上の角)にクイーンがある場合を考えてみます。他の３つ
 # の角にクイーンを置くことはできないので(効き筋だから）、ユニーク解であるかどうか
 # を判定するには、右上角から左下角を通る斜軸で反転させたパターンとの比較だけになり
 # ます。突き詰めれば、
 # 
 # [上から２行目のクイーンの位置が右から何番目にあるか]
 # [右から２列目のクイーンの位置が上から何番目にあるか]
 # 
 #
 # を比較するだけで判定することができます。この２つの値が同じになることはないからです。
 # 
 #       3 0
 #       ↓↓
 # - - - - Q ←0
 # - Q - - - ←3
 # - - - - -         上から２行目のクイーンの位置が右から４番目にある。
 # - - - Q -         右から２列目のクイーンの位置が上から４番目にある。
 # - - - - -         しかし、互いの効き筋にあたるのでこれは有り得ない。
 # 
 #   結局、再帰探索中において下図の X への配置を禁止する枝刈りを入れておけば、得
 # られる解は総てユニーク解であることが保証されます。
 # 
 # - - - - X Q
 # - Q - - X -
 # - - - - X -
 # - - - - X -
 # - - - - - -
 # - - - - - -
 # 
 #   次に右端以外にクイーンがある場合を考えてみます。オリジナルがユニーク解である
 # ためには先ず下図の X への配置は禁止されます。よって、その枝刈りを先ず入れておき
 # ます。
 # 
 # X X - - - Q X X
 # X - - - - - - X
 # - - - - - - - -
 # - - - - - - - -
 # - - - - - - - -
 # - - - - - - - -
 # X - - - - - - X
 # X X - - - - X X
 # 
 #   次にクイーンの利き筋を辿っていくと、結局、オリジナルがユニーク解ではない可能
 # 性があるのは、下図の A,B,C の位置のどこかにクイーンがある場合に限られます。従っ
 # て、90度回転、180度回転、270度回転の３通りの変換パターンだけを調べれはよいこと
 # になります。
 # 
 # X X x x x Q X X
 # X - - - x x x X
 # C - - x - x - x
 # - - x - - x - -
 # - x - - - x - -
 # x - - - - x - A
 # X - - - - x - X
 # X X B - - x X X
 #
 #
 # ■ユニーク解から全解への展開
 #   これまでの考察はユニーク解の個数を求めるためのものでした。全解数を求めるには
 # ユニーク解を求めるための枝刈りを取り除いて全探索する必要があります。したがって
 # 探索時間を犠牲にしてしまうことになります。そこで「ユニーク解の個数から全解数を
 # 導いてしまおう」という試みが考えられます。これは、左右反転によるパターンの探索
 # を省略して最後に結果を２倍するというアイデアの拡張版といえるものです。そしてそ
 # れを実現させるには「あるユニーク解が属するグループの要素数はいくつあるのか」と
 # いう考察が必要になってきます。
 # 
 #   最初に、クイーンが右上角にあるユニーク解を考えます。斜軸で反転したパターンが
 # オリジナルと同型になることは有り得ないことと(×２)、右上角のクイーンを他の３つの
 # 角に写像させることができるので(×４)、このユニーク解が属するグループの要素数は必
 # ず８個(＝２×４)になります。
 # 
 #   次に、クイーンが右上角以外にある場合は少し複雑になりますが、考察を簡潔にする
 # ために次の事柄を確認します。
 #
 # TOTAL = (COUNT8 * 8) + (COUNT4 * 4) + (COUNT2 * 2);
 #   (1) 90度回転させてオリジナルと同型になる場合、さらに90度回転(オリジナルか
 #    ら180度回転)させても、さらに90度回転(オリジナルから270度回転)させてもオリ
 #    ジナルと同型になる。  
 #
 #    COUNT2 * 2
 # 
 #   (2) 90度回転させてオリジナルと異なる場合は、270度回転させても必ずオリジナ
 #    ルとは異なる。ただし、180度回転させた場合はオリジナルと同型になることも有
 #    り得る。 
 #
 #    COUNT4 * 4
 # 
 #   (3) (1) に該当するユニーク解が属するグループの要素数は、左右反転させたパターンを
 #       加えて２個しかありません。(2)に該当するユニーク解が属するグループの要素数は、
 #       180度回転させて同型になる場合は４個(左右反転×縦横回転)、そして180度回転させても
 #       オリジナルと異なる場合は８個になります。(左右反転×縦横回転×上下反転)
 # 
 #    COUNT8 * 8 
 #
 #   以上のことから、ひとつひとつのユニーク解が上のどの種類に該当するのかを調べる
 # ことにより全解数を計算で導き出すことができます。探索時間を短縮させてくれる枝刈
 # りを外す必要がなくなったというわけです。 
 # 
 #   UNIQUE  COUNT2      +  COUNT4      +  COUNT8
 #   TOTAL  (COUNT2 * 2) + (COUNT4 * 4) + (COUNT8 * 8)
 #
 # 　これらを実現すると、前回のNQueen3()よりも実行速度が遅くなります。
 # 　なぜなら、対称・反転・斜軸を反転するための処理が加わっているからです。
 # ですが、今回の処理を行うことによって、さらにNQueen5()では、処理スピードが飛
 # 躍的に高速化されます。そのためにも今回のアルゴリズム実装は必要なのです。
 #
 #
 # N:        Total       Unique     hh:mm:ss
 # 2:            0            0            0
 # 3:            0            0            0
 # 4:            2            1            0
 # 5:           10            2            0
 # 6:            4            1            0
 # 7:           40            6            0
 # 8:           92           12            0
 # 9:          352           46            0
 #10:          724           92            0
 #11:         2680          341            3
 #12:        14200         1787           18
 #13:        73712         9233           99
 #14:       365596        45752          573
 #15:      2279184       285053         3511
 #
