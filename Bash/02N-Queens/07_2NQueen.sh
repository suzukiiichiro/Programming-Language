#!/bin/bash

##
 # Bash(シェルスクリプト)で学ぶアルゴリズムとデータ構造  
 # 一般社団法人  共同通信社  情報技術局  鈴木  維一郎(suzuki.iichiro@kyodonews.jp)
 #
 # Java/C/Lua/Bash版
 # https://github.com/suzukiiichiro/N-Queen
 #
 # ステップバイステップでＮ−クイーン問題を最適化
 #  １．ブルートフォース（力まかせ探索） NQueen1()
 #<>２．配置フラグ（制約テスト高速化）   NQueen2()
 #  ３．バックトラック                   NQueen3()
 #  ４．ビットマップ                     NQueen4()
 #  ５．ユニーク解                       NQueen5()

#
##
 # ２．配置フラグ（制約テスト高速化）
 #  パターンを生成し終わってからチェックを行うのではなく、途中で制約を満たさな
 #  い事が明らかな場合は、それ以降のパターン生成を行わない。
 # 「手を進められるだけ進めて、それ以上は無理（それ以上進めても解はない）という
 # 事がわかると一手だけ戻ってやり直す」という考え方で全ての手を調べる方法。
 # (※)各行列に一個の王妃配置する組み合わせを再帰的に列挙分枝走査を行っても、組
 # み合わせを列挙するだけであって、8王妃問題を解いているわけではありません。
 #
#  :
#  :
#  7 6 5 4 2 0 3 1 : 40310
#  7 6 5 4 2 1 0 3 : 40311
#  7 6 5 4 2 1 3 0 : 40312
#  7 6 5 4 2 3 0 1 : 40313
#  7 6 5 4 2 3 1 0 : 40314
#  7 6 5 4 3 0 1 2 : 40315
#  7 6 5 4 3 0 2 1 : 40316
#  7 6 5 4 3 1 0 2 : 40317
#  7 6 5 4 3 1 2 0 : 40318
#  7 6 5 4 3 2 0 1 : 40319
#  7 6 5 4 3 2 1 0 : 40320

c=1 ;
N-Queen2(){
  local -i i=$1 j= size=$2 ;
  for ((j=0;j<size;j++)) {
    [[ -z "${flag_a[j]}" ]] && {
      pos[i]="$j" ; 
      ((i==(size-1)))&&{
        echo -n "$((c++)): " ;
        for((i=0;i<size;i++)){
          echo -n "${pos[i]}" ;
        }
        echo "" ;
      }||{
        flag_a[j]="true" ;         
        N-Queen2 "$((i+1))" "$size" ;
        flag_a[j]="" ; 
      }
    }
  }
}

N-Queen2 0 8;      # 配置フラグ
exit ;
