	


================================================================================

	Programming C Launguage   ---- Vol. 1

================================================================================


Index 	
  １．プログラミングの流れ
	２．C言語の書式とプログラムの実行順序
	３．関数の使い方
	４．数値データ型
	５．文字列データ型
	６．ポインタ
	７．配列
	８．構造体
	９．演算子
	１０．条件分岐１
	１１．条件分岐２
	１２．繰り返し処理１
	１３．繰り返し処理２
	１４．プリプロセッサ
	１５．関数の作成
	１６．アドレスと構造体

かつてMS-DOS時代にはC言語をで作成されていましたがWindows時代の主力プログラミングツールはC++
へと変化し今では色々と種類もあるとは思いますが所詮VisualC++には叶いません。
VC++をマスターすることがWindows時代を生き抜くプログラマの必須条件です。

VC++にいきなり食らいついてはいけません。ウイザードが自動生成する意味不明なコードを前に四苦八
苦することになるだけです。VC++はC++をベースとした開発ツールです。C++を理解できなければHTMLを
知らずしてホームページをFromtPageで作成しようとするのと同じです。きっとすぐに壁にぶち当たる
ことでしょう。だからといって最初からC++を理解することにも無理があります。Cから順番に理解する
ことが必要です。

C言語での山場　アドレスとポインタや構造体と共用体がC++に引き継がれてクラスという概念を使って
オブジェクト指向プログラミングを可能にしています。このオブジェクト指向がまた難解なのでいきな
りC++は難しいのです。

VC++をマスターするにはC++のクラスとオブジェクト指向プログラミングを理解する必要があります。
それを理解するためにCを学ぶ必要があるのです。


=================*=====================*======================*====================
１．プログラミングの流れ

	テキストエディタ（メモ帳や秀丸）でC言語のソースファイルを作成する
	今回は直接VC++へ記述

	ソースファイルをコンパイル　F7
	(オブジェクトファイルとライブラリファイルをリンクして実行ファイルを得る）

	エラーがあればデバッグする

	エラーと警告が無くなったら実行する　F5

	動作確認

	// Note ///////////////////////////////////////////////////////////////
		C言語のソースファイルは純粋なテキストファイルです
		ソースファイルをコンパイルすると拡張子が*.objとなったマシン語の
		オブジェクトファイルとなります。
		*.objファイルとライブラリファイル*.libをリンク（結合）すると
		実行ファイル（拡張子*.exe）が作成されます

	## Execute ############################################################
		#include <stdio.h>
		main()
		{
			printf("Hello world") ;
		} // End main()


=================*=====================*======================*====================
２．C言語の書式とプログラムの実行順序

	/* 画面に文字列を表示する */
	#include <stdio.h>
	main()
	{
		puts("Hello world") ;
	} // End main()

	記述は全て半角のアルファベットを使用
	コメント/* */も基本的には英数小文字を使うことが望ましい
	コメントは/* と　*/で囲む
	#include 文は記述の先頭に
	プログラムはmainという予約された名前の関数から実行される
	関数の後ろにはパラメータの有無に関わらずカッコを付ける
	１つの関数のブロックは{ と }で囲む
	関数のブロック内ではコードの末尾にセミコロンを付ける
	main関数の末尾またはexit命令が実行されるとプログラムが終了する

	// Note ///////////////////////////////////////////////////////
		C言語の書式はフリーフォーマットです
		TABキーを使ってすっきり見やすく記述するのが基本です
		今回はリスト２の記述方法をDefaultとします

		リスト１------------------------------------------------
		#include <stdio.h>
		main()
		{
			int a ;

			a = 123 ;

			if(a >= 100)
			{
				printf("100 Over") ;
			} // End if
			else
			{
				printf("100 Under") ;
			} // End else

		} // End main()

		リスト２------------------------------------------------
		#include <stdio.h>
		main()	{

 			int a ;
			a = 123 ;

			if(a >= 100) {
				printf("100 Over") ;
			} else {
				printf("100 Under") ;
			} // End if

		} // End main()

		## Execute ###############################################
		#include <stdio.h>

		main()	{
			puts("Main function") ;
			sub1() ;
			puts("End Main function") ;
		} // End main();

		sub1()	{
			puts("sub1 function") ;
			sub2() ;
			puts("End sub1 function") ;
		} // End sub1() ;

		sub2() {
			puts("sub2 function") ;
			puts("End sub2 function") ;
		} // End sub2() ;


=================*=====================*======================*====================
３．関数の使い方

	関数構文の表し方
		戻り値のデータ型　関数名（パラメータのデータ型　パラメータ名）
	関数のパラメータ名とそのデータ型はかっこの中に書く。
	複数のパラメータがある場合はそれらをカンマで区切る。
	省略可能なパラメータもある
	戻り値を返す関数は関数名の前に戻り値のデータ型が指定される。
	使用する関数の種類によってインクルードするヘッダファイルの種類が異なる。
	関数名やパラメータ名の前にあるアスタリスク(*)はポインタを表す。

	// Note //////////////////////////////////////////////////////////////
		#include でソースファイルの中にインクルードしていたヘッダファイル
		には関数の構文が記述されています。
		C言語のコンパイラは指定されたヘッダファイルを参照する事でソース
		ファイルに記述された関数の構文チェックを行います。
		ヘッダファイルもC言語のファイル同様に純粋なテキストファイルなので
		興味のある人はメモ帳などで見て下さい。
		"C:\Program Files\DevStudio\VC\include"

		ポインタについては後述しますがすなわちメモリアドレスの事です
		それに変数を与える場合は変数名の前にアンパサンド(&)を付けるようにします
		これは変数名自体がメモリに格納されたデータの値を表し、それにアンパサンド
		を付けるとアドレスを表すようになっているからです。

		int MyFunc(int MyParem1, int *MyParem2) ;

		int i, j, k ;
		i = MyFunc(j, &k) ;

	## Execute #############################################################
		キーボードから文字列を入力	stdio.h
		画面に文字列を表示		stdio.h
		文字列の長さを返す		string.h
		数値を文字列に変換		stdlib.h

		#include <stdio.h>
		#include <string.h>
		#include <stdlib.h>

		main(){
			char s[80] ;
			int i ;

			puts("Input characters line") ;
			gets(s) ;

			i = strlen(s) ;

			puts(itoa(i, s, 10)) ;

			return(0) ;
		} // End main() ;

=================*=====================*======================*====================
４．数値データ型

	関数の戻り値、関数のパラメータ、変数、及び定数はデータ型を持つ
	データ型は大きく分けると数値データと文字列データに分けられる

	int 		16bit (MS-DOS)	-- shortと同じ
			32bit (Windows) -- longと同じ

	char		8bit	-128 --- 127
	unsigned char	8bit 	0  ----- 255

	short		16bit 	-32768-- 32767
	unsigned short	16bit	0 ------ 65535

	long		32bit	-214783648 -------- 2147483647
	unsigned long	32bit	0 ------ 4294967295

	float		32bit	------------------------
	double		64bit   ------------------------

	// Note ////////////////////////////////////////////////////////
		C言語の宣言では関数名や変数名の前にデータ型を表すキーワードを明記する
		整数型を表す　int 型や 文字列型のcharや浮動小数点型のfloat等を使い分ける

		C言語の変数は関数ブロック内の先頭、または関数の外に宣言できる。
		関数ブロック内で宣言された変数（内部変数）は同じ関数の内部に記述された
		プログラムコードからのみ参照できます
		関数の外で宣言された変数（外部変数）は全ての関数から参照出来ます。


		int a ; 	// 外部関数（グローバル関数）
				// 他の関数も参照出来ます
		main(){

		int b ;		// 内部関数（インライン関数）
				// main関数の内部だけで参照出来ます

		} // End main() ;


		かっこの中にデータ型を記述した物を変数や定数の前に記述すると強制的に
		データ変換が行われるようになります。これをキャストと言います。

		char c ;
		int i ;
		long l ;

		i = (int)c + (int)l
		char型のcをint型に変換
		long型のlをint型に変換

		## Execute ########################################################
		#include <stdio.h>

		main(){
			int a, b, c ;

			printf("Type your most favorite number and press Enter") ;
			scanf("%d", &a) ;

			printf("Type your second favorite number and press Enter") ;
			scanf("%d", &b) ;

			c = a + b ;

			printf("Most Favorite + Second Favorite value is %d\n", c) ;

			return(0) ;
		} // End main ()


=================*=====================*======================*====================
５．文字列データ型

	C言語には文字列を格納する専用のデータ型がない。
	文字列は１文字を格納できるchar型データの配列として取り扱われる
	文字列の中に開業などの特殊なデータを含める場合は\マークに続く１文字で表す

	文字データ型の種類
		１文字	char		char c ;
		文字列	charの配列	char s[80] ;
	文字数の種類
		１文字		'A'
		文字列		"ABC"
		改行		\n
		ヌル文字	\0

	// Note /////////////////////////////////////////////////////////////////
		文字を１文字表示する場合はchar
		文字列を表示させるときに気を付けることは文字列の末尾にゼロを格納する
		事で文字列の終わりを表すようになっていてこれをヌル終了文字列と呼びます。
		ダブルコーテーションで囲まれた文字列定数には末尾に自動的にゼロが格納
		されるようになっています。
		よって文字列データは見かけよりも１文字多い配列数が必要と言う事になります。
		文字列専用のデータ型がないのでC言語では代入演算子(=)を使った文字列の一括
		格納が出来ません。文字列の格納には　strcpyを使います

	## Execute ###############################################################
		#include <stdio.h>
		#include <string.h>

		main(){
			char s[5], d[5] ;

			printf("この文字列は改行しません") ;
			printf("この文字列は改行します\n") ;

			s[0] = 'A' ;
			s[1] = 'B' ;
			s[2] = 'C' ;
			s[3] = 'D' ;
			s[4] = '\0' ;

			puts(s) ;

			strcpy(d, s) ;
			puts(d) ;

			return(0) ;
		}  // End main


=================*=====================*======================*====================
６．ポインタ

	ポインタはC言語をマスターする時の最大の難関であると言われています。
	変数はメモリを表し値とアドレスという２つの属性があります。
	変数のアドレスがすなわちポインタとなります。
	コンパイルされてマシン語となった関数もメモリ上に格納されています。
	関数のポインタは関数の入り口となるマシンご命令が格納されたメモリ上のアドレスです。

	ポインタ型の変数はアスタリスク(*)を付けて宣言します。

	int a ;		// 通常の変数
	int *a ;	// ポインタ型の変数

	ポインタ型の変数が保持しているデータはメモリアドレスです。
	ポインタ型の変数にアスタリスクを付けて参照すると、メモリの内容すなわち
	データの値を取得できます。

	通常の変数の前にアンパサンド（&)を付けるとその変数のメモリアドレスを取得する
	事が出来ます。


	// Note //////////////////////////////////////////////////////////////
	ポインタを使える。すなわちメモリアドレスを参照出来ると言う事はC言語の
	大きな特徴の一つである。

	以下のプログラムはaに代入した10をポインタを使用して表示する物です。

	#include <stdio.h>
	main() {
			int a ;
			int *z ;

			a = 10 ;
			z = &a ;

			printf("%d\n", *z) ;
	} // End main() ;

	まず&aに着目します。
	aという変数には10という正数の値が代入されています。
	&aにはこのaの値が記憶されている場所（記憶領域）の番号が代入されています。
	いわばaという変数の住所のような物です。

	&a は　変数aの値(10)が記憶されている場所の住所を示す--- アドレス

	ポインタの宣言には*アスタリスクを付けます。
	このポインタは変数のアドレスを記憶するための変数です。
	ここではポインタzに変数aのアドレスである&aを代入しています。

	ポインタ変数zにアドレス&aを記憶する

	zに格納されている&aの値10を*zによって表示します。


	// ポインタ 2 ///////////////////////////////////////////////////////

	ポインタが活躍するのはそれが関数のパラメータとして使われる場合である。
	以下の記述はパラメータに与えられた２つの変数を交換するMySwap関数だが
	正しく動作しない。
	関数のパラメータがポインタ型ではないためメモリを参照出来ないからである。
	すなわちパラメータaとbの値をメモリから取得してそれを交換して再び元の
	メモリに戻す事が出来ないからである。
	main関数よりも前にMySwap関数を記述しているのはMySwap関数の構文をコンパイラに
	事前に知らせる為である。

	#include <stdio.h>

	void MySwap(int a, int b) {
			int c ;

			c = a ;
			a = b ;
			b = c ;
	}

	main() {
		int i, j ;

		i = 123 ;
		j = 456 ;

		MySwap(&i, &j) ;

		printf("i = %d, j = %d\n", i, j) ;

		return(0) ;

	}  // End main() ;


	## Execute ###########################################################
	#include <stdio.h>

	void MySwap(int *a, int *b) {
			int c ;

			c = *a ;
			*a = *b ;
			*b = c ;
	}

	main() {
		int i, j ;

		i = 123 ;
		j = 456 ;

		MySwap(&i, &j) ;

		printf("i = %d, j = %d\n", i, j) ;

		return(0) ;

	}  // End main() ;


=================*=====================*======================*====================
７．配列　と　ポインタ

	C言語ではあらゆるデータ型の変数を配列にする事が出来る。
	配列のインデックスを変更することで配列を構成する任意のデータの格納と取得が出来る。
	配列はポインタ型の変数と似た所がある。

	配列はインデックスを [ ] で囲んで宣言する
		char c[80] ;
		int i[50] ;
		double d[30] ;

	配列のインデックスはゼロから始まります。
		char c[5] ;はc[0]----c[4]までのインデックスを用意します。
		[0]	[1]	[2]	[3]	[4]

	２次元配列はインデックスを並べて宣言します。
	int a[5][5] ;
			[0][1]	[0][2]	[0][3]	[0][4]	[0][5]
			[1][1]	[1][2]	[1][3]	[1][4]	[1][5]
			[2][1]	[2][2]	[2][3]	[2][4]	[2][5]
			[3][1]	[3][2]	[3][3]	[3][4]	[3][5]
			[4][1]	[4][2]	[4][3]	[4][4]	[4][5]

	// Note ///////////////////////////////////////////////////////////////
		配列は連続したメモリ領域をインデックスを指定することで参照出来るように
		した物である。
		配列とポインタ変数が似ているのはどちらも連続したメモリ領域をそれらの
		変数が宣言された時のデータ型のサイズ単位で読み書き出来ると言う事である。

		配列のインデックスを一つ増減することとポインタ型の変数をインクリメント
		またはデクリメントすることは同じ事である。

		配列 int i[10] ;	メモリ		ポインタ int *j ;
			i[0]		100番地			j ;
			i[1]		102番地			(j + 1) ;
			i[2]		104番地			(j + 2) ;
			i[3]		106番地			(j + 3) ;
			i[4]		108番地			(j + 4) ;

	## Execute ###############################################################
		#include <stdio.h>

		main() {

			int  a[3] ;
			int *z ;

			a[0] = 10 ;
			a[1] = 20 ;
			a[2] = 30 ;

			z = a ;

			printf("%d, %d, %d\n", a[0], a[1], a[2]) ;
			printf("%d, %d, %d\n", *z, *(z + 1), *(z + 2)) ;

			printf("%d, %d, %d\n", *z, *z + 1, *z + 2) ;

			return(0) ;

		} // End main() ;


=================*=====================*======================*====================
８．構造体

	構造体とは複数のデータ型を組み合わせて作成する新しいデータ型である。
	構造体を使う事で関連性のあるデータを一つにまとめる事が出来る。

	構造体を定義することにより新しいデータ型を作成する事が出来る

	struct NewData			// NewDataという構造体の定義
	{
		char name[40] ;		// 構造体のメンバ変数を配列で宣言
		char address[80] ;	// 構造体のメンバ変数を配列で宣言
		char tel[20] ;		// 構造体のメンバ変数を配列で宣言
		int age ;
	} ;				// セミコロンを忘れずに


	// Note /////////////////////////////////////////////////////////////////
	構造体を定義すればそれを一般的なデータ型の変数と同様に宣言して使える

		struct NewData a ;	// NewData型の変数aを宣言

	構造体のメンバ（ここの要素）は構造体型の変数にどっと(.)を付けて参照する

		strcpy(a.name, "鈴木維一郎") ;
		// 構造体aのメンバ変数nameに文字列鈴木維一郎を格納
		// 文字列の場合はstrcpyを使う

		a.age = 38 ;
		// 構造体a のメンバ変数ageに値38を格納

	構造体のポインタ型変数では　-> 演算子でメンバを参照する

		struct NewData *p ;
		// NewData型のポインタ型変数pの宣言
		p = &a ;
		// pにaのアドレスを格納
		p -> age = 30 ;
		// pのメンバ変数ageに整数値を格納

	## Execut #################################################################

	#include <stdio.h>
	#include <string.h>

	struct MyStruc {
		char c[20] ;
		int i ;
		long l ;
	} ;

	void sub(struct MyStruc *data) {
		strcpy (data -> c, "ABC") ;
		data -> i = 123 ;
		data -> l = 456 ;
	} // End sub() ;

	main() {
		struct MyStruc a ;
		sub(&a) ;

		printf("%s, %d, %d\n", a.c, a.i, a.l) ;

		return(0) ;

	} // End main() ;


=================*=====================*======================*====================
９．演算子

	+	加算		a = b + c ;
	- 	減算		a = b - c ;
	*	乗算		a = b * c ;
	/	除算		a = b / c ;
	% 	剰余		a = b % c ;
	++	インクリメント	a++ ;　++a (a = a + 1) ;と同じ
	--	デクリメント	a-- ;  --a (a = a - 1) ;と同じ
	=	代入		a = b ;

	---------------------------------

	>	より大きい	if(a > b)
	<
	>=
	<=
	==	等しい		if(a == b)
	!=	等しくない	if(a != b)
	&&	And		if((a > b) && (a < c))
	||	Or		if((a > b) || (a < c))
	!	Not		if(!(a > b))

	---------------------------------

	<< 	左シフト	a = b << 4 ;
	>>

	----------------------------------

	sizeof	バイトサイズ	i = sizeof(a) ;
	?:	条件分岐	a > 3 ? b = 1 : b = 2 ;
				(論理式 ? True : False)

	## Execute #############################################################

	#include <stdio.h>

	main() {
		int i ;

		sizeof(i) == 2 ?
			puts("2 bite") :
			puts("Not 2 bite") ;
	} // End main() ;


=================*=====================*======================*====================
１０．条件分岐

	C言語にはあらゆる条件葺きが行えるif文と、制限付きながら
	効率的な条件分岐が行えるswitch文がある。ここではif文について学びます。

	if文の構文１
		if (演算式）{
			演算式の値が真の場合に実行される命令
		} // End if


	if 文の構文２
		if (演算式）{
			演算式の値が真の場合に実行される命令
		} else {
			演算式の値が偽の場合に実行される命令
		} // End if

	if 文の構文３
		if (演算式）{
			演算式の値が真の場合に実行される命令
		} else if (演算式1）{
			演算式1の値が真の場合に実行される命令
		} else {
			演算式1 かつ　演算式2 の値が偽の場合に実行される命令
		} // End if

	// Note /////////////////////////////////////////////////////////////

	条件分岐はif以下に記述された演算式の結果が真偽によってプログラムの流れを
	制御する物である。

	if文に限らず、条件分岐や繰り返し処理を行う構文の末尾にはセミコロン(;)を
	付けない
	また中かっこの中に記述する命令が１行の場合は中かっこを省略する事が出来ます。

	## Execute ###########################################################

	#include <stdio.h>

	main() {
		int i ;

		printf("1-12の数字を入力して下さい。") ;
		scanf("%d", &i) ;

		if (i == 1)
			puts("January") ;
		else if( i == 2)
			puts("Jebruary") ;
			//.
			//.
			//.
		else
			puts("1-12の数字だってばさ・・・") ;

		return(0) ;

	} // End main() ;

=================*=====================*======================*====================
１１．条件分岐 2

	switch文は１つの比較項目が様々な値を取る場合の条件分岐を効率的に行う物である。

	switch文の構文その1
		switch(式) {
			case 値: 1
			式の値が値1と等しい場合に実行される命令 ;
			break ;
			case 値: 2
			式の値が値2と等しい場合に実行される命令 ;
			break ;
			case 値: 3
			式の値が値3と等しい場合に実行される命令 ;
			break ;
			case 値: 4
			式の値が値4と等しい場合に実行される命令 ;
			break ;
			case 値: 5
			式の値が値5と等しい場合に実行される命令 ;
			break ;
			default :
			式の値が値１から値３のいずれとも等しくない場合に実行される命令 ;
		} // End switch


	switch文の構文その2
		switch(式) {
			case 値: 1
			式の値が値1と等しい場合に実行される命令 ;
			case 値: 2
			式の値が値1または2に等しい場合に実行される命令 ;
			case 値: 3
			式の値が値１または２または3と等しい場合に実行される命令 ;
			break ;
			default :
			式の値が値１から値３のいずれとも等しくない場合に実行される命令 ;
		} // End switch

	// Note ////////////////////////////////////////////////////////////////
	if文は万能な条件分岐が可能だが、switch文は比較する式が１つだけであり、
	式の値がchar型またはint型でなければならないと言う制限がある。

	switch以降の式には変数や関数が記述される
	break ;はswitch文を抜けるための命令である。
	付けないとそれ以降のcase以下の値との比較も行われこれによってOr条件を表す事も
	出来ます。
	default以下は全ての比較に一致しない（すなわちbreak ;が実行されない）場合に
	実行される

	## Execute #############################################################

	#include <stdio.h>

	main() {
		int i ;

		printf("Input value your favorite nuber 1 - 12" ) ;
		scanf("%d", &i) ;

		switch(i) {
			case 1:puts("January") ;	break ;
			case 2:puts("February") ;	break ;
			case 3:puts("March") ;		break ;
			case 4:puts("April") ;		break ;
			case 5:puts("May") ;		break ;
			case 6:puts("June") ;		break ;
			case 7:puts("July") ;		break ;
			case 8:puts("August") ;		break ;
			case 9:puts("September") ;	break ;
			case 10:puts("October") ;	break ;
			case 11:puts("November") ;	break ;
			case 12:puts("December") ;	break ;
			default : puts("Error") ;
		} // End switch
		return(0) ;
	} // End main() ;

=================*=====================*======================*====================
１２．繰り返し処理

	for文の構文
	for(式1 ;式2 ;式3 ;) {
		繰り返し実行される命令
	} // End for

	for文の例

	int i ;
	for (i = 0 ; i <0 ; i++) ;{
		puts("10 times loop") ;
	} // End for

	// Note ///////////////////////////////////////////////////////////////
	式１にはループカウンタの初期化(i = 0)
	式２には繰り返しの継続条件(i < 10)
	式３にはループカウンタの更新(i++)

	## Execute ############################################################

	#include <stdio.h>

	main() {
		int i, j ;
		for (i = 1 ;i <= 9 ; i++) {
			printf("%dの段：", i) ;

			for(j= 1 ;j <=9 ;J++) {
				printf("%2d", i * j) ;
			} // End for2

			printf("\n") ;
		} // End for 1


=================*=====================*======================*====================
１３．繰り返し処理２

	演算子の値が真となるまで繰り返しを継続するwhile文にはwhileを先頭に記述する場合と
	末尾に記述する場合がある

	while 構文　１

	while (式）{
		繰り返し実行される命令
	} // End while

	while 構文２

	do {
		繰り返し実行される命令
	} while (式) ;

	// Note /////////////////////////////////////////////////////////////////////
	while 文は式の値が真である限り繰り返しが継続される。
	式には比較演算子だけではなく、何らかの値を返す命令なら何を記述しても良い

	whileを末尾に記述した場合は、少なくとも１回は繰り返しが行われる
	この場合にはwhileの行末にセミコロンを付けることに注意して欲しい。

	## Execute ##################################################################

	#include <stdio.h>
	#include <string.h>

	main() {
		char num[20] ;
		int i, sum ;

		do {
			printf("4桁の数値を入力して下さい") ;
			scanf("%s", num) ;
		} while (strlen(num) != 4) ;

		i = 0 ;
		sum = 0 ;
		while (num[i] != '\n') {
			sum *= (num[i] - 0x30) ;
			i++ ;
		} // End while

		printf("各桁の合計 %d\n", sum) ;

		return(0) ;
	} // End main() ;


=================*=====================*======================*====================
１４．プリプロセッサ

	プリプロセッサとはプログラムのコードの中に記述するコンパイラへの命令の事である。
	プリプロセッサを使うことでヘッダファイルのインクルード、定数やマクロの定義、
	及び条件コンパイルが行える。

	#include 		他のファイルをインクルードする
	#define 		定数及びマクロを定義する(文字列を置き換える）
	#if  --- #endif		条件コンパイルを行う
	#ifdef --- #endif	条件コンパイルを行う

	// Note ////////////////////////////////////////////////////////////////
	プリプロセッサは#で始まり行末にセミコロンをつけないことが特徴です
	プリプロセッサ自体はマシン語に変換される物ではありません。

	#includeでヘッダファイルをインクルードすると、ヘッダファイルに記述された
	内容がそのままソースファイルに記述されている物としてコンパイルが行われます。

	標準関数の構文（プロトタイプ宣言）構造体、及び定数などが定義されたヘッダファイル
	をインクルードすれば関数の構文チェックが行われ、構造体や定数がすぐに使えるように
	なります。

	複数のソースファイルから参照される情報を１つのヘッダファイルにまとめておくと
	効率的なプログラミングが出来るようになります。

	#defineには２つの使い方がある。
	１つは定数を定義することであり、もう１つはパラメータを持ったマクロを定義する
	ことである。
	もう１つはパラメータを持ったマクロを定義することである。

		#define OK(-1)
		#define NG 0

		#define MAX(a, b) ((a >= b) ? a : b)

	条件コンパイルの指定方法は２種類ある。
	ソースファイルで#ifと#endifで囲まれた部分は#if以下に記述された条件式が
	真の場合だけコンパイルされる。

	## Execute ############################################################

	#include <stdio.h>
	#define Yes (-1)
	#define NO 0
	#define DEBUGMODE YES
	#define MAX(a, b) ((a >= b) ? a : b)

	main() {
		int i, j, k ;

		#if DEBUGMODE == YES
			puts("DEBUG MODE") ;
		#endif

		printf("１つ目の数を入力して下さい") ;
		scanf("%D", &i) ;
		printf("２つ目の数を入力して下さい") ;
		scanf("%D", &j) ;

		k = MAX(i, j) ;
		printf("大きい数は　%d です\n", k) ;

		return(0) ;
	} // End main() ;


=================*=====================*======================*====================
１５．関数の作成

	C言語のプログラムは複数の関数を組み合わせて作成される。
	１つの関数または関連する機能を持った関数のセットを１つのソースファイルと
	することがC言語の流儀である。
	main関数以外の関数は必ず他の関数から呼び出されるのでそのプロトタイプ宣言が
	記述されたヘッダファイルを作成しておく必要がある。

		Header file -----------------
		戻り値のデータ型　関数名　（パラメータのデータ型　パラメータ名）
		int MyFunc(int MyParam1, char *MyPatam2) ;

		Source file -----------------
		戻り値のデータ型　関数名　（パラメータのデータ型　パラメータ名）{
			関数独自の処理 ;
			return(0) ;
		}

	// Note //////////////////////////////////////////////////////////////////
		本格的なC言語のプログラムではソースファイルを複数に分割し、それぞれを
		単独でコンパイルしてオブジェクトファイルを作成し最後に全てのオブジェクト
		ファイルとC言語の標準関数が収録されたライブラリファイルをリンクして実行
		ファイルを作成する

		ヘッダファイルに記述された関数のプロトタイプ宣言はその関数を使うコードが
		記述されたソースファイルでコンパイラが構文チェックを行うために参照される。

		戻り値を返さない関数の場合は関数の戻り値のデータ型にvoidを指定する
		この場合は関数の末尾でreturn命令を使って戻り値を返さないようにする

	## Execute ################################################################

		#include <stdio.h>

		int AddInt(int a, int b) {
			return a + b ;
		} // End AddInt

		int SubInt(int a, int b) {
			return a - b ;
		} // End SubInt

		int MulInt(int a, int b) {
			return a * b ;
		} // End MulInt

		int DivInt(int a, int b) {
			return a / b ;
		} // End DivInt

		main() {
			int i ;
			int j ;

			printf("１つ目の数値を入力して下さい") ;
			scanf("%d", &i) ;
			printf("２つ目の数値を入力して下さい") ;
			scanf("%d", &j) ;

			printf("Add a + b = %d\n", AddInt(i, j)) ;
			printf("Sub a - b = %d\n", SubInt(i, j)) ;
			printf("Mul a * b = %d\n", MulInt(i, j)) ;
			printf("Div a / b = %d\n", DivInt(i, j)) ;

			return(0) ;

		}  // End main() ;



==============================================================================


